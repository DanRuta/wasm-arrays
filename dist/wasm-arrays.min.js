"use strict";const ccallArrays=(r,e,a,{heapIn:t="HEAPF32",heapOut:A="HEAPF32",returnArraySize:s=1}={})=>{const l={};l.HEAP8=Int8Array,l.HEAPU8=Uint8Array,l.HEAP16=Int16Array,l.HEAPU16=Uint16Array,l.HEAP32=Int32Array,l.HEAPU32=Uint32Array,l.HEAPF32=Float32Array,l.HEAPF64=Float64Array;const n="array"==e?"number":e,c=[],u=[],E=[];let y,h;try{if(a)for(let r=0;r<a.length;r++)if(Array.isArray(a[r])){const e=new l[t](a[r].length);for(let t=0;t<a[r].length;t++)e[t]=a[r][t];const A=Module._malloc(e.length*e.BYTES_PER_ELEMENT);switch(t){case"HEAP8":case"HEAPU8":Module[t].set(e,A);break;case"HEAP16":case"HEAPU16":Module[t].set(e,A>>1);break;case"HEAP32":case"HEAPU32":case"HEAPF32":Module[t].set(e,A>>2);break;case"HEAPF64":Module[t].set(e,A>>3)}E.push(A),c.push(A),c.push(a[r].length),u.push("number"),u.push("number")}else c.push(a[r]),u.push(typeof a[r]);y=Module.ccall(r,n,u,c)}catch(r){h=r}finally{for(let r=0;r<E.length;r++)Module._free(E[r])}if(h)throw h;if("array"==e){const r=[];for(let e=0;e<s;e++)r.push(Module[A][y/l[A].BYTES_PER_ELEMENT+e]);return r}return y},cwrapArrays=(r,e,{heapIn:a="HEAPF32",heapOut:t="HEAPF32",returnArraySize:A=1}={})=>s=>ccallArrays(r,e,s,{heapIn:a,heapOut:t,returnArraySize:A});"undefined"==typeof window&&(exports.ccallArrays=ccallArrays,exports.cwrapArrays=((r,e,{heapIn:a="HEAPF32",heapOut:t="HEAPF32",returnArraySize:A=1}={})=>s=>ccallArrays(r,e,s,{heapIn:a,heapOut:t,returnArraySize:A})));